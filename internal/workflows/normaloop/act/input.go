// Code generated by schema-generate. DO NOT EDIT.

package act

import (
    "bytes"
    "encoding/json"
    "errors"
)

// ActAcceptanceResult 
type ActAcceptanceResult struct {
  AcId string `json:"ac_id"`
  LogRef string `json:"log_ref,omitempty"`
  Notes string `json:"notes,omitempty"`
  Result string `json:"result"`
}

// ActBudgets 
type ActBudgets struct {
  MaxFailedChecks int64 `json:"max_failed_checks,omitempty"`
  MaxIterations int64 `json:"max_iterations"`
  MaxWallTimeMinutes int64 `json:"max_wall_time_minutes,omitempty"`
}

// ActCheckVerdict 
type ActCheckVerdict struct {
  Basis *ActCheckVerdictBasis `json:"basis"`
  Recommendation string `json:"recommendation"`
  Status string `json:"status"`
}

// ActCheckVerdictBasis 
type ActCheckVerdictBasis struct {
  AllAcceptancePassed bool `json:"all_acceptance_passed,omitempty"`
  PlanMatch string `json:"plan_match,omitempty"`
}

// ActContext 
type ActContext struct {
  Attempt int64 `json:"attempt,omitempty"`
  Facts *ActFacts `json:"facts,omitempty"`
  Links []string `json:"links,omitempty"`
}

// ActFacts 
type ActFacts struct {
}

// ActInput 
type ActInput struct {
  AcceptanceResults []ActAcceptanceResult `json:"acceptance_results,omitempty"`
  CheckVerdict *ActCheckVerdict `json:"check_verdict"`
}

// ActPaths 
type ActPaths struct {
  CodeRoot string `json:"code_root,omitempty"`
  RunDir string `json:"run_dir"`
  WorkspaceDir string `json:"workspace_dir"`
  WorkspaceMode string `json:"workspace_mode,omitempty"`
}

// ActRequest 
type ActRequest struct {
  ActInput *ActInput `json:"act_input"`
  Budgets *ActBudgets `json:"budgets,omitempty"`
  Context *ActContext `json:"context,omitempty"`
  Paths *ActPaths `json:"paths"`
  Run *ActRun `json:"run"`
  Step *ActStep `json:"step"`
  StopReasonsAllowed []string `json:"stop_reasons_allowed,omitempty"`
  Task *ActTask `json:"task"`
}

// ActRun 
type ActRun struct {
  Id string `json:"id"`
  Iteration int64 `json:"iteration"`
}

// ActStep 
type ActStep struct {
  Dir string `json:"dir"`
  Index int64 `json:"index"`
  Name string `json:"name"`
}

// ActTask 
type ActTask struct {
  AcceptanceCriteria []interface{} `json:"acceptance_criteria"`
  Description string `json:"description"`
  Id string `json:"id"`
  Title string `json:"title"`
}

func (strct *ActAcceptanceResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ac_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"ac_id\": ")
	if tmp, err := json.Marshal(strct.AcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "log_ref" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"log_ref\": ")
	if tmp, err := json.Marshal(strct.LogRef); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "notes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActAcceptanceResult) UnmarshalJSON(b []byte) error {
    ac_idReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ac_id":
            if err := json.Unmarshal([]byte(v), &strct.AcId); err != nil {
                return err
             }
            ac_idReceived = true
        case "log_ref":
            if err := json.Unmarshal([]byte(v), &strct.LogRef); err != nil {
                return err
             }
        case "notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
                return err
             }
            resultReceived = true
        }
    }
    // check if ac_id (a required property) was received
    if !ac_idReceived {
        return errors.New("\"ac_id\" is required but was not present")
    }
    // check if result (a required property) was received
    if !resultReceived {
        return errors.New("\"result\" is required but was not present")
    }
    return nil
}

func (strct *ActBudgets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "max_failed_checks" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_failed_checks\": ")
	if tmp, err := json.Marshal(strct.MaxFailedChecks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MaxIterations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "max_iterations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_iterations\": ")
	if tmp, err := json.Marshal(strct.MaxIterations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "max_wall_time_minutes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_wall_time_minutes\": ")
	if tmp, err := json.Marshal(strct.MaxWallTimeMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActBudgets) UnmarshalJSON(b []byte) error {
    max_iterationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "max_failed_checks":
            if err := json.Unmarshal([]byte(v), &strct.MaxFailedChecks); err != nil {
                return err
             }
        case "max_iterations":
            if err := json.Unmarshal([]byte(v), &strct.MaxIterations); err != nil {
                return err
             }
            max_iterationsReceived = true
        case "max_wall_time_minutes":
            if err := json.Unmarshal([]byte(v), &strct.MaxWallTimeMinutes); err != nil {
                return err
             }
        }
    }
    // check if max_iterations (a required property) was received
    if !max_iterationsReceived {
        return errors.New("\"max_iterations\" is required but was not present")
    }
    return nil
}

func (strct *ActCheckVerdict) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Basis" field is required
    if strct.Basis == nil {
        return nil, errors.New("basis is a required field")
    }
    // Marshal the "basis" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"basis\": ")
	if tmp, err := json.Marshal(strct.Basis); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Recommendation" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "recommendation" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recommendation\": ")
	if tmp, err := json.Marshal(strct.Recommendation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActCheckVerdict) UnmarshalJSON(b []byte) error {
    basisReceived := false
    recommendationReceived := false
    statusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "basis":
            if err := json.Unmarshal([]byte(v), &strct.Basis); err != nil {
                return err
             }
            basisReceived = true
        case "recommendation":
            if err := json.Unmarshal([]byte(v), &strct.Recommendation); err != nil {
                return err
             }
            recommendationReceived = true
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        }
    }
    // check if basis (a required property) was received
    if !basisReceived {
        return errors.New("\"basis\" is required but was not present")
    }
    // check if recommendation (a required property) was received
    if !recommendationReceived {
        return errors.New("\"recommendation\" is required but was not present")
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    return nil
}

func (strct *ActInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "acceptance_results" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"acceptance_results\": ")
	if tmp, err := json.Marshal(strct.AcceptanceResults); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CheckVerdict" field is required
    if strct.CheckVerdict == nil {
        return nil, errors.New("check_verdict is a required field")
    }
    // Marshal the "check_verdict" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"check_verdict\": ")
	if tmp, err := json.Marshal(strct.CheckVerdict); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActInput) UnmarshalJSON(b []byte) error {
    check_verdictReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acceptance_results":
            if err := json.Unmarshal([]byte(v), &strct.AcceptanceResults); err != nil {
                return err
             }
        case "check_verdict":
            if err := json.Unmarshal([]byte(v), &strct.CheckVerdict); err != nil {
                return err
             }
            check_verdictReceived = true
        }
    }
    // check if check_verdict (a required property) was received
    if !check_verdictReceived {
        return errors.New("\"check_verdict\" is required but was not present")
    }
    return nil
}

func (strct *ActPaths) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "code_root" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"code_root\": ")
	if tmp, err := json.Marshal(strct.CodeRoot); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RunDir" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "run_dir" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"run_dir\": ")
	if tmp, err := json.Marshal(strct.RunDir); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkspaceDir" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "workspace_dir" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"workspace_dir\": ")
	if tmp, err := json.Marshal(strct.WorkspaceDir); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "workspace_mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"workspace_mode\": ")
	if tmp, err := json.Marshal(strct.WorkspaceMode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActPaths) UnmarshalJSON(b []byte) error {
    run_dirReceived := false
    workspace_dirReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "code_root":
            if err := json.Unmarshal([]byte(v), &strct.CodeRoot); err != nil {
                return err
             }
        case "run_dir":
            if err := json.Unmarshal([]byte(v), &strct.RunDir); err != nil {
                return err
             }
            run_dirReceived = true
        case "workspace_dir":
            if err := json.Unmarshal([]byte(v), &strct.WorkspaceDir); err != nil {
                return err
             }
            workspace_dirReceived = true
        case "workspace_mode":
            if err := json.Unmarshal([]byte(v), &strct.WorkspaceMode); err != nil {
                return err
             }
        }
    }
    // check if run_dir (a required property) was received
    if !run_dirReceived {
        return errors.New("\"run_dir\" is required but was not present")
    }
    // check if workspace_dir (a required property) was received
    if !workspace_dirReceived {
        return errors.New("\"workspace_dir\" is required but was not present")
    }
    return nil
}

func (strct *ActRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ActInput" field is required
    if strct.ActInput == nil {
        return nil, errors.New("act_input is a required field")
    }
    // Marshal the "act_input" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"act_input\": ")
	if tmp, err := json.Marshal(strct.ActInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "budgets" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"budgets\": ")
	if tmp, err := json.Marshal(strct.Budgets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "context" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"context\": ")
	if tmp, err := json.Marshal(strct.Context); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Paths" field is required
    if strct.Paths == nil {
        return nil, errors.New("paths is a required field")
    }
    // Marshal the "paths" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"paths\": ")
	if tmp, err := json.Marshal(strct.Paths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Run" field is required
    if strct.Run == nil {
        return nil, errors.New("run is a required field")
    }
    // Marshal the "run" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"run\": ")
	if tmp, err := json.Marshal(strct.Run); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Step" field is required
    if strct.Step == nil {
        return nil, errors.New("step is a required field")
    }
    // Marshal the "step" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"step\": ")
	if tmp, err := json.Marshal(strct.Step); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stop_reasons_allowed" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop_reasons_allowed\": ")
	if tmp, err := json.Marshal(strct.StopReasonsAllowed); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Task" field is required
    if strct.Task == nil {
        return nil, errors.New("task is a required field")
    }
    // Marshal the "task" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"task\": ")
	if tmp, err := json.Marshal(strct.Task); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActRequest) UnmarshalJSON(b []byte) error {
    act_inputReceived := false
    pathsReceived := false
    runReceived := false
    stepReceived := false
    taskReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "act_input":
            if err := json.Unmarshal([]byte(v), &strct.ActInput); err != nil {
                return err
             }
            act_inputReceived = true
        case "budgets":
            if err := json.Unmarshal([]byte(v), &strct.Budgets); err != nil {
                return err
             }
        case "context":
            if err := json.Unmarshal([]byte(v), &strct.Context); err != nil {
                return err
             }
        case "paths":
            if err := json.Unmarshal([]byte(v), &strct.Paths); err != nil {
                return err
             }
            pathsReceived = true
        case "run":
            if err := json.Unmarshal([]byte(v), &strct.Run); err != nil {
                return err
             }
            runReceived = true
        case "step":
            if err := json.Unmarshal([]byte(v), &strct.Step); err != nil {
                return err
             }
            stepReceived = true
        case "stop_reasons_allowed":
            if err := json.Unmarshal([]byte(v), &strct.StopReasonsAllowed); err != nil {
                return err
             }
        case "task":
            if err := json.Unmarshal([]byte(v), &strct.Task); err != nil {
                return err
             }
            taskReceived = true
        }
    }
    // check if act_input (a required property) was received
    if !act_inputReceived {
        return errors.New("\"act_input\" is required but was not present")
    }
    // check if paths (a required property) was received
    if !pathsReceived {
        return errors.New("\"paths\" is required but was not present")
    }
    // check if run (a required property) was received
    if !runReceived {
        return errors.New("\"run\" is required but was not present")
    }
    // check if step (a required property) was received
    if !stepReceived {
        return errors.New("\"step\" is required but was not present")
    }
    // check if task (a required property) was received
    if !taskReceived {
        return errors.New("\"task\" is required but was not present")
    }
    return nil
}

func (strct *ActRun) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Iteration" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "iteration" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"iteration\": ")
	if tmp, err := json.Marshal(strct.Iteration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActRun) UnmarshalJSON(b []byte) error {
    idReceived := false
    iterationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "iteration":
            if err := json.Unmarshal([]byte(v), &strct.Iteration); err != nil {
                return err
             }
            iterationReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if iteration (a required property) was received
    if !iterationReceived {
        return errors.New("\"iteration\" is required but was not present")
    }
    return nil
}

func (strct *ActStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Dir" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "dir" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"dir\": ")
	if tmp, err := json.Marshal(strct.Dir); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActStep) UnmarshalJSON(b []byte) error {
    dirReceived := false
    indexReceived := false
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "dir":
            if err := json.Unmarshal([]byte(v), &strct.Dir); err != nil {
                return err
             }
            dirReceived = true
        case "index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
                return err
             }
            indexReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        }
    }
    // check if dir (a required property) was received
    if !dirReceived {
        return errors.New("\"dir\" is required but was not present")
    }
    // check if index (a required property) was received
    if !indexReceived {
        return errors.New("\"index\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *ActTask) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcceptanceCriteria" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "acceptance_criteria" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"acceptance_criteria\": ")
	if tmp, err := json.Marshal(strct.AcceptanceCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ActTask) UnmarshalJSON(b []byte) error {
    acceptance_criteriaReceived := false
    descriptionReceived := false
    idReceived := false
    titleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acceptance_criteria":
            if err := json.Unmarshal([]byte(v), &strct.AcceptanceCriteria); err != nil {
                return err
             }
            acceptance_criteriaReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
            descriptionReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        }
    }
    // check if acceptance_criteria (a required property) was received
    if !acceptance_criteriaReceived {
        return errors.New("\"acceptance_criteria\" is required but was not present")
    }
    // check if description (a required property) was received
    if !descriptionReceived {
        return errors.New("\"description\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    return nil
}
