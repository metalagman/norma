// Code generated by schema-generate. DO NOT EDIT.

package plan

import (
    "encoding/json"
    "errors"
    "bytes"
)

// ACCheck 
type ACCheck struct {
  Cmd string `json:"cmd"`
  ExpectExitCodes []int64 `json:"expect_exit_codes"`
  Id string `json:"id"`
}

// BaselineAC 
type BaselineAC struct {
  Id string `json:"id"`
  Text string `json:"text"`
  VerifyHints []string `json:"verify_hints,omitempty"`
}

// EffectiveAC 
type EffectiveAC struct {
  Checks []ACCheck `json:"checks"`
  Id string `json:"id"`
  Origin string `json:"origin"`
  Reason string `json:"reason,omitempty"`
  Refines []string `json:"refines,omitempty"`
  Text string `json:"text"`
}

// PlanAcceptanceCriteria 
type PlanAcceptanceCriteria struct {
  Baseline []BaselineAC `json:"baseline"`
  Effective []EffectiveAC `json:"effective"`
}

// PlanCheckStep 
type PlanCheckStep struct {
  Id string `json:"id"`
  Mode string `json:"mode"`
  Text string `json:"text"`
}

// PlanCommand 
type PlanCommand struct {
  Cmd string `json:"cmd"`
  ExpectExitCodes []int64 `json:"expect_exit_codes"`
  Id string `json:"id"`
}

// PlanDoStep 
type PlanDoStep struct {
  Commands []PlanCommand `json:"commands"`
  Id string `json:"id"`
  TargetsAcIds []string `json:"targets_ac_ids"`
  Text string `json:"text"`
}

// PlanLogs 
type PlanLogs struct {
  StderrPath string `json:"stderr_path,omitempty"`
  StdoutPath string `json:"stdout_path,omitempty"`
}

// PlanOutput 
type PlanOutput struct {
  AcceptanceCriteria *PlanAcceptanceCriteria `json:"acceptance_criteria"`
  Constraints []string `json:"constraints,omitempty"`
  Goal string `json:"goal"`
  TaskId string `json:"task_id"`
  WorkPlan *PlanWorkPlan `json:"work_plan"`
}

// PlanProgress 
type PlanProgress struct {
  Details []string `json:"details"`
  Title string `json:"title"`
}

// PlanResponse 
type PlanResponse struct {
  Logs *PlanLogs `json:"logs,omitempty"`
  PlanOutput *PlanOutput `json:"plan_output"`
  Progress *PlanProgress `json:"progress"`
  Status string `json:"status"`
  StopReason string `json:"stop_reason,omitempty"`
  Summary *PlanSummary `json:"summary"`
  Timing *PlanTiming `json:"timing,omitempty"`
}

// PlanSummary 
type PlanSummary struct {
  Errors []string `json:"errors,omitempty"`
  Text string `json:"text"`
  Warnings []string `json:"warnings,omitempty"`
}

// PlanTiming 
type PlanTiming struct {
  WallTimeMs int64 `json:"wall_time_ms,omitempty"`
}

// PlanWorkPlan 
type PlanWorkPlan struct {
  CheckSteps []PlanCheckStep `json:"check_steps"`
  DoSteps []PlanDoStep `json:"do_steps"`
  StopTriggers []string `json:"stop_triggers"`
  TimeboxMinutes int64 `json:"timebox_minutes"`
}

func (strct *ACCheck) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Cmd" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "cmd" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"cmd\": ")
	if tmp, err := json.Marshal(strct.Cmd); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ExpectExitCodes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "expect_exit_codes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"expect_exit_codes\": ")
	if tmp, err := json.Marshal(strct.ExpectExitCodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ACCheck) UnmarshalJSON(b []byte) error {
    cmdReceived := false
    expect_exit_codesReceived := false
    idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cmd":
            if err := json.Unmarshal([]byte(v), &strct.Cmd); err != nil {
                return err
             }
            cmdReceived = true
        case "expect_exit_codes":
            if err := json.Unmarshal([]byte(v), &strct.ExpectExitCodes); err != nil {
                return err
             }
            expect_exit_codesReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        }
    }
    // check if cmd (a required property) was received
    if !cmdReceived {
        return errors.New("\"cmd\" is required but was not present")
    }
    // check if expect_exit_codes (a required property) was received
    if !expect_exit_codesReceived {
        return errors.New("\"expect_exit_codes\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    return nil
}

func (strct *BaselineAC) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "verify_hints" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"verify_hints\": ")
	if tmp, err := json.Marshal(strct.VerifyHints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BaselineAC) UnmarshalJSON(b []byte) error {
    idReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        case "verify_hints":
            if err := json.Unmarshal([]byte(v), &strct.VerifyHints); err != nil {
                return err
             }
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *EffectiveAC) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Checks" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "checks" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"checks\": ")
	if tmp, err := json.Marshal(strct.Checks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Origin" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "origin" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"origin\": ")
	if tmp, err := json.Marshal(strct.Origin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "reason" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"reason\": ")
	if tmp, err := json.Marshal(strct.Reason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "refines" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"refines\": ")
	if tmp, err := json.Marshal(strct.Refines); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EffectiveAC) UnmarshalJSON(b []byte) error {
    checksReceived := false
    idReceived := false
    originReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "checks":
            if err := json.Unmarshal([]byte(v), &strct.Checks); err != nil {
                return err
             }
            checksReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "origin":
            if err := json.Unmarshal([]byte(v), &strct.Origin); err != nil {
                return err
             }
            originReceived = true
        case "reason":
            if err := json.Unmarshal([]byte(v), &strct.Reason); err != nil {
                return err
             }
        case "refines":
            if err := json.Unmarshal([]byte(v), &strct.Refines); err != nil {
                return err
             }
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if checks (a required property) was received
    if !checksReceived {
        return errors.New("\"checks\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if origin (a required property) was received
    if !originReceived {
        return errors.New("\"origin\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *PlanAcceptanceCriteria) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Baseline" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "baseline" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"baseline\": ")
	if tmp, err := json.Marshal(strct.Baseline); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Effective" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "effective" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"effective\": ")
	if tmp, err := json.Marshal(strct.Effective); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanAcceptanceCriteria) UnmarshalJSON(b []byte) error {
    baselineReceived := false
    effectiveReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "baseline":
            if err := json.Unmarshal([]byte(v), &strct.Baseline); err != nil {
                return err
             }
            baselineReceived = true
        case "effective":
            if err := json.Unmarshal([]byte(v), &strct.Effective); err != nil {
                return err
             }
            effectiveReceived = true
        }
    }
    // check if baseline (a required property) was received
    if !baselineReceived {
        return errors.New("\"baseline\" is required but was not present")
    }
    // check if effective (a required property) was received
    if !effectiveReceived {
        return errors.New("\"effective\" is required but was not present")
    }
    return nil
}

func (strct *PlanCheckStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Mode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanCheckStep) UnmarshalJSON(b []byte) error {
    idReceived := false
    modeReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
            modeReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if mode (a required property) was received
    if !modeReceived {
        return errors.New("\"mode\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *PlanCommand) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Cmd" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "cmd" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"cmd\": ")
	if tmp, err := json.Marshal(strct.Cmd); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "ExpectExitCodes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "expect_exit_codes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"expect_exit_codes\": ")
	if tmp, err := json.Marshal(strct.ExpectExitCodes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanCommand) UnmarshalJSON(b []byte) error {
    cmdReceived := false
    expect_exit_codesReceived := false
    idReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cmd":
            if err := json.Unmarshal([]byte(v), &strct.Cmd); err != nil {
                return err
             }
            cmdReceived = true
        case "expect_exit_codes":
            if err := json.Unmarshal([]byte(v), &strct.ExpectExitCodes); err != nil {
                return err
             }
            expect_exit_codesReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        }
    }
    // check if cmd (a required property) was received
    if !cmdReceived {
        return errors.New("\"cmd\" is required but was not present")
    }
    // check if expect_exit_codes (a required property) was received
    if !expect_exit_codesReceived {
        return errors.New("\"expect_exit_codes\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    return nil
}

func (strct *PlanDoStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Commands" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "commands" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"commands\": ")
	if tmp, err := json.Marshal(strct.Commands); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TargetsAcIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "targets_ac_ids" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"targets_ac_ids\": ")
	if tmp, err := json.Marshal(strct.TargetsAcIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanDoStep) UnmarshalJSON(b []byte) error {
    commandsReceived := false
    idReceived := false
    targets_ac_idsReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "commands":
            if err := json.Unmarshal([]byte(v), &strct.Commands); err != nil {
                return err
             }
            commandsReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "targets_ac_ids":
            if err := json.Unmarshal([]byte(v), &strct.TargetsAcIds); err != nil {
                return err
             }
            targets_ac_idsReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if commands (a required property) was received
    if !commandsReceived {
        return errors.New("\"commands\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if targets_ac_ids (a required property) was received
    if !targets_ac_idsReceived {
        return errors.New("\"targets_ac_ids\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *PlanOutput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcceptanceCriteria" field is required
    if strct.AcceptanceCriteria == nil {
        return nil, errors.New("acceptance_criteria is a required field")
    }
    // Marshal the "acceptance_criteria" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"acceptance_criteria\": ")
	if tmp, err := json.Marshal(strct.AcceptanceCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "constraints" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"constraints\": ")
	if tmp, err := json.Marshal(strct.Constraints); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Goal" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "goal" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"goal\": ")
	if tmp, err := json.Marshal(strct.Goal); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TaskId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "task_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"task_id\": ")
	if tmp, err := json.Marshal(strct.TaskId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkPlan" field is required
    if strct.WorkPlan == nil {
        return nil, errors.New("work_plan is a required field")
    }
    // Marshal the "work_plan" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"work_plan\": ")
	if tmp, err := json.Marshal(strct.WorkPlan); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanOutput) UnmarshalJSON(b []byte) error {
    acceptance_criteriaReceived := false
    goalReceived := false
    task_idReceived := false
    work_planReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acceptance_criteria":
            if err := json.Unmarshal([]byte(v), &strct.AcceptanceCriteria); err != nil {
                return err
             }
            acceptance_criteriaReceived = true
        case "constraints":
            if err := json.Unmarshal([]byte(v), &strct.Constraints); err != nil {
                return err
             }
        case "goal":
            if err := json.Unmarshal([]byte(v), &strct.Goal); err != nil {
                return err
             }
            goalReceived = true
        case "task_id":
            if err := json.Unmarshal([]byte(v), &strct.TaskId); err != nil {
                return err
             }
            task_idReceived = true
        case "work_plan":
            if err := json.Unmarshal([]byte(v), &strct.WorkPlan); err != nil {
                return err
             }
            work_planReceived = true
        }
    }
    // check if acceptance_criteria (a required property) was received
    if !acceptance_criteriaReceived {
        return errors.New("\"acceptance_criteria\" is required but was not present")
    }
    // check if goal (a required property) was received
    if !goalReceived {
        return errors.New("\"goal\" is required but was not present")
    }
    // check if task_id (a required property) was received
    if !task_idReceived {
        return errors.New("\"task_id\" is required but was not present")
    }
    // check if work_plan (a required property) was received
    if !work_planReceived {
        return errors.New("\"work_plan\" is required but was not present")
    }
    return nil
}

func (strct *PlanProgress) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Details" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "details" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"details\": ")
	if tmp, err := json.Marshal(strct.Details); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanProgress) UnmarshalJSON(b []byte) error {
    detailsReceived := false
    titleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "details":
            if err := json.Unmarshal([]byte(v), &strct.Details); err != nil {
                return err
             }
            detailsReceived = true
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        }
    }
    // check if details (a required property) was received
    if !detailsReceived {
        return errors.New("\"details\" is required but was not present")
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    return nil
}

func (strct *PlanResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "logs" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"logs\": ")
	if tmp, err := json.Marshal(strct.Logs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "PlanOutput" field is required
    if strct.PlanOutput == nil {
        return nil, errors.New("plan_output is a required field")
    }
    // Marshal the "plan_output" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"plan_output\": ")
	if tmp, err := json.Marshal(strct.PlanOutput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Progress" field is required
    if strct.Progress == nil {
        return nil, errors.New("progress is a required field")
    }
    // Marshal the "progress" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"progress\": ")
	if tmp, err := json.Marshal(strct.Progress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stop_reason" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop_reason\": ")
	if tmp, err := json.Marshal(strct.StopReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Summary" field is required
    if strct.Summary == nil {
        return nil, errors.New("summary is a required field")
    }
    // Marshal the "summary" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "timing" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"timing\": ")
	if tmp, err := json.Marshal(strct.Timing); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanResponse) UnmarshalJSON(b []byte) error {
    plan_outputReceived := false
    progressReceived := false
    statusReceived := false
    summaryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "logs":
            if err := json.Unmarshal([]byte(v), &strct.Logs); err != nil {
                return err
             }
        case "plan_output":
            if err := json.Unmarshal([]byte(v), &strct.PlanOutput); err != nil {
                return err
             }
            plan_outputReceived = true
        case "progress":
            if err := json.Unmarshal([]byte(v), &strct.Progress); err != nil {
                return err
             }
            progressReceived = true
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        case "stop_reason":
            if err := json.Unmarshal([]byte(v), &strct.StopReason); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
            summaryReceived = true
        case "timing":
            if err := json.Unmarshal([]byte(v), &strct.Timing); err != nil {
                return err
             }
        }
    }
    // check if plan_output (a required property) was received
    if !plan_outputReceived {
        return errors.New("\"plan_output\" is required but was not present")
    }
    // check if progress (a required property) was received
    if !progressReceived {
        return errors.New("\"progress\" is required but was not present")
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    // check if summary (a required property) was received
    if !summaryReceived {
        return errors.New("\"summary\" is required but was not present")
    }
    return nil
}

func (strct *PlanSummary) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "errors" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"errors\": ")
	if tmp, err := json.Marshal(strct.Errors); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "warnings" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"warnings\": ")
	if tmp, err := json.Marshal(strct.Warnings); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanSummary) UnmarshalJSON(b []byte) error {
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "errors":
            if err := json.Unmarshal([]byte(v), &strct.Errors); err != nil {
                return err
             }
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        case "warnings":
            if err := json.Unmarshal([]byte(v), &strct.Warnings); err != nil {
                return err
             }
        }
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *PlanWorkPlan) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CheckSteps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "check_steps" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"check_steps\": ")
	if tmp, err := json.Marshal(strct.CheckSteps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DoSteps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "do_steps" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"do_steps\": ")
	if tmp, err := json.Marshal(strct.DoSteps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StopTriggers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stop_triggers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop_triggers\": ")
	if tmp, err := json.Marshal(strct.StopTriggers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TimeboxMinutes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "timebox_minutes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"timebox_minutes\": ")
	if tmp, err := json.Marshal(strct.TimeboxMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PlanWorkPlan) UnmarshalJSON(b []byte) error {
    check_stepsReceived := false
    do_stepsReceived := false
    stop_triggersReceived := false
    timebox_minutesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "check_steps":
            if err := json.Unmarshal([]byte(v), &strct.CheckSteps); err != nil {
                return err
             }
            check_stepsReceived = true
        case "do_steps":
            if err := json.Unmarshal([]byte(v), &strct.DoSteps); err != nil {
                return err
             }
            do_stepsReceived = true
        case "stop_triggers":
            if err := json.Unmarshal([]byte(v), &strct.StopTriggers); err != nil {
                return err
             }
            stop_triggersReceived = true
        case "timebox_minutes":
            if err := json.Unmarshal([]byte(v), &strct.TimeboxMinutes); err != nil {
                return err
             }
            timebox_minutesReceived = true
        }
    }
    // check if check_steps (a required property) was received
    if !check_stepsReceived {
        return errors.New("\"check_steps\" is required but was not present")
    }
    // check if do_steps (a required property) was received
    if !do_stepsReceived {
        return errors.New("\"do_steps\" is required but was not present")
    }
    // check if stop_triggers (a required property) was received
    if !stop_triggersReceived {
        return errors.New("\"stop_triggers\" is required but was not present")
    }
    // check if timebox_minutes (a required property) was received
    if !timebox_minutesReceived {
        return errors.New("\"timebox_minutes\" is required but was not present")
    }
    return nil
}
