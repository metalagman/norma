// Code generated by schema-generate. DO NOT EDIT.

package check

import (
    "errors"
    "bytes"
    "encoding/json"
)

// CheckAcceptanceCriterion 
type CheckAcceptanceCriterion struct {
  Id string `json:"id"`
  Text string `json:"text"`
}

// CheckBudgets 
type CheckBudgets struct {
  MaxFailedChecks int64 `json:"max_failed_checks,omitempty"`
  MaxIterations int64 `json:"max_iterations"`
  MaxWallTimeMinutes int64 `json:"max_wall_time_minutes,omitempty"`
}

// CheckCheckStep 
type CheckCheckStep struct {
  Id string `json:"id"`
  Mode string `json:"mode"`
  Text string `json:"text"`
}

// CheckContext 
type CheckContext struct {
  Attempt int64 `json:"attempt,omitempty"`
  Facts *Facts `json:"facts,omitempty"`
  Links []string `json:"links,omitempty"`
}

// CheckDoExecution 
type CheckDoExecution struct {
  ExecutedStepIds []string `json:"executed_step_ids"`
  SkippedStepIds []string `json:"skipped_step_ids"`
}

// CheckDoStep 
type CheckDoStep struct {
  Id string `json:"id"`
  Text string `json:"text"`
}

// CheckEffectiveAC 
type CheckEffectiveAC struct {
  Id string `json:"id"`
  Origin string `json:"origin"`
  Text string `json:"text"`
}

// CheckInput 
type CheckInput struct {
  AcceptanceCriteriaEffective []CheckEffectiveAC `json:"acceptance_criteria_effective"`
  DoExecution *CheckDoExecution `json:"do_execution"`
  WorkPlan *CheckWorkPlan `json:"work_plan"`
}

// CheckPaths 
type CheckPaths struct {
  Progress string `json:"progress"`
  RunDir string `json:"run_dir"`
  WorkspaceDir string `json:"workspace_dir"`
}

// CheckRequest 
type CheckRequest struct {
  Budgets *CheckBudgets `json:"budgets,omitempty"`
  CheckInput *CheckInput `json:"check_input"`
  Context *CheckContext `json:"context,omitempty"`
  Paths *CheckPaths `json:"paths"`
  Run *CheckRun `json:"run"`
  Step *CheckStep `json:"step"`
  StopReasonsAllowed []string `json:"stop_reasons_allowed,omitempty"`
  Task *CheckTask `json:"task"`
}

// CheckRun 
type CheckRun struct {
  Id string `json:"id"`
  Iteration int64 `json:"iteration"`
}

// CheckStep 
type CheckStep struct {
  Index int64 `json:"index"`
  Name string `json:"name"`
}

// CheckTask 
type CheckTask struct {
  AcceptanceCriteria []CheckAcceptanceCriterion `json:"acceptance_criteria"`
  Description string `json:"description"`
  Id string `json:"id"`
  Title string `json:"title"`
}

// CheckWorkPlan 
type CheckWorkPlan struct {
  CheckSteps []CheckCheckStep `json:"check_steps"`
  DoSteps []CheckDoStep `json:"do_steps"`
  StopTriggers []string `json:"stop_triggers"`
  TimeboxMinutes int64 `json:"timebox_minutes"`
}

// Facts 
type Facts struct {
}

func (strct *CheckAcceptanceCriterion) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckAcceptanceCriterion) UnmarshalJSON(b []byte) error {
    idReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *CheckBudgets) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "max_failed_checks" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_failed_checks\": ")
	if tmp, err := json.Marshal(strct.MaxFailedChecks); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "MaxIterations" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "max_iterations" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_iterations\": ")
	if tmp, err := json.Marshal(strct.MaxIterations); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "max_wall_time_minutes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"max_wall_time_minutes\": ")
	if tmp, err := json.Marshal(strct.MaxWallTimeMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckBudgets) UnmarshalJSON(b []byte) error {
    max_iterationsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "max_failed_checks":
            if err := json.Unmarshal([]byte(v), &strct.MaxFailedChecks); err != nil {
                return err
             }
        case "max_iterations":
            if err := json.Unmarshal([]byte(v), &strct.MaxIterations); err != nil {
                return err
             }
            max_iterationsReceived = true
        case "max_wall_time_minutes":
            if err := json.Unmarshal([]byte(v), &strct.MaxWallTimeMinutes); err != nil {
                return err
             }
        }
    }
    // check if max_iterations (a required property) was received
    if !max_iterationsReceived {
        return errors.New("\"max_iterations\" is required but was not present")
    }
    return nil
}

func (strct *CheckCheckStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Mode" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "mode" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"mode\": ")
	if tmp, err := json.Marshal(strct.Mode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckCheckStep) UnmarshalJSON(b []byte) error {
    idReceived := false
    modeReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "mode":
            if err := json.Unmarshal([]byte(v), &strct.Mode); err != nil {
                return err
             }
            modeReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if mode (a required property) was received
    if !modeReceived {
        return errors.New("\"mode\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *CheckDoExecution) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "ExecutedStepIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "executed_step_ids" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"executed_step_ids\": ")
	if tmp, err := json.Marshal(strct.ExecutedStepIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "SkippedStepIds" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "skipped_step_ids" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"skipped_step_ids\": ")
	if tmp, err := json.Marshal(strct.SkippedStepIds); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckDoExecution) UnmarshalJSON(b []byte) error {
    executed_step_idsReceived := false
    skipped_step_idsReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "executed_step_ids":
            if err := json.Unmarshal([]byte(v), &strct.ExecutedStepIds); err != nil {
                return err
             }
            executed_step_idsReceived = true
        case "skipped_step_ids":
            if err := json.Unmarshal([]byte(v), &strct.SkippedStepIds); err != nil {
                return err
             }
            skipped_step_idsReceived = true
        }
    }
    // check if executed_step_ids (a required property) was received
    if !executed_step_idsReceived {
        return errors.New("\"executed_step_ids\" is required but was not present")
    }
    // check if skipped_step_ids (a required property) was received
    if !skipped_step_idsReceived {
        return errors.New("\"skipped_step_ids\" is required but was not present")
    }
    return nil
}

func (strct *CheckDoStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckDoStep) UnmarshalJSON(b []byte) error {
    idReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *CheckEffectiveAC) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Origin" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "origin" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"origin\": ")
	if tmp, err := json.Marshal(strct.Origin); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckEffectiveAC) UnmarshalJSON(b []byte) error {
    idReceived := false
    originReceived := false
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "origin":
            if err := json.Unmarshal([]byte(v), &strct.Origin); err != nil {
                return err
             }
            originReceived = true
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if origin (a required property) was received
    if !originReceived {
        return errors.New("\"origin\" is required but was not present")
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *CheckInput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcceptanceCriteriaEffective" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "acceptance_criteria_effective" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"acceptance_criteria_effective\": ")
	if tmp, err := json.Marshal(strct.AcceptanceCriteriaEffective); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DoExecution" field is required
    if strct.DoExecution == nil {
        return nil, errors.New("do_execution is a required field")
    }
    // Marshal the "do_execution" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"do_execution\": ")
	if tmp, err := json.Marshal(strct.DoExecution); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkPlan" field is required
    if strct.WorkPlan == nil {
        return nil, errors.New("work_plan is a required field")
    }
    // Marshal the "work_plan" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"work_plan\": ")
	if tmp, err := json.Marshal(strct.WorkPlan); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckInput) UnmarshalJSON(b []byte) error {
    acceptance_criteria_effectiveReceived := false
    do_executionReceived := false
    work_planReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acceptance_criteria_effective":
            if err := json.Unmarshal([]byte(v), &strct.AcceptanceCriteriaEffective); err != nil {
                return err
             }
            acceptance_criteria_effectiveReceived = true
        case "do_execution":
            if err := json.Unmarshal([]byte(v), &strct.DoExecution); err != nil {
                return err
             }
            do_executionReceived = true
        case "work_plan":
            if err := json.Unmarshal([]byte(v), &strct.WorkPlan); err != nil {
                return err
             }
            work_planReceived = true
        }
    }
    // check if acceptance_criteria_effective (a required property) was received
    if !acceptance_criteria_effectiveReceived {
        return errors.New("\"acceptance_criteria_effective\" is required but was not present")
    }
    // check if do_execution (a required property) was received
    if !do_executionReceived {
        return errors.New("\"do_execution\" is required but was not present")
    }
    // check if work_plan (a required property) was received
    if !work_planReceived {
        return errors.New("\"work_plan\" is required but was not present")
    }
    return nil
}

func (strct *CheckPaths) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Progress" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "progress" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"progress\": ")
	if tmp, err := json.Marshal(strct.Progress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "RunDir" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "run_dir" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"run_dir\": ")
	if tmp, err := json.Marshal(strct.RunDir); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "WorkspaceDir" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "workspace_dir" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"workspace_dir\": ")
	if tmp, err := json.Marshal(strct.WorkspaceDir); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckPaths) UnmarshalJSON(b []byte) error {
    progressReceived := false
    run_dirReceived := false
    workspace_dirReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "progress":
            if err := json.Unmarshal([]byte(v), &strct.Progress); err != nil {
                return err
             }
            progressReceived = true
        case "run_dir":
            if err := json.Unmarshal([]byte(v), &strct.RunDir); err != nil {
                return err
             }
            run_dirReceived = true
        case "workspace_dir":
            if err := json.Unmarshal([]byte(v), &strct.WorkspaceDir); err != nil {
                return err
             }
            workspace_dirReceived = true
        }
    }
    // check if progress (a required property) was received
    if !progressReceived {
        return errors.New("\"progress\" is required but was not present")
    }
    // check if run_dir (a required property) was received
    if !run_dirReceived {
        return errors.New("\"run_dir\" is required but was not present")
    }
    // check if workspace_dir (a required property) was received
    if !workspace_dirReceived {
        return errors.New("\"workspace_dir\" is required but was not present")
    }
    return nil
}

func (strct *CheckRequest) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "budgets" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"budgets\": ")
	if tmp, err := json.Marshal(strct.Budgets); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "CheckInput" field is required
    if strct.CheckInput == nil {
        return nil, errors.New("check_input is a required field")
    }
    // Marshal the "check_input" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"check_input\": ")
	if tmp, err := json.Marshal(strct.CheckInput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "context" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"context\": ")
	if tmp, err := json.Marshal(strct.Context); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Paths" field is required
    if strct.Paths == nil {
        return nil, errors.New("paths is a required field")
    }
    // Marshal the "paths" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"paths\": ")
	if tmp, err := json.Marshal(strct.Paths); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Run" field is required
    if strct.Run == nil {
        return nil, errors.New("run is a required field")
    }
    // Marshal the "run" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"run\": ")
	if tmp, err := json.Marshal(strct.Run); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Step" field is required
    if strct.Step == nil {
        return nil, errors.New("step is a required field")
    }
    // Marshal the "step" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"step\": ")
	if tmp, err := json.Marshal(strct.Step); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stop_reasons_allowed" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop_reasons_allowed\": ")
	if tmp, err := json.Marshal(strct.StopReasonsAllowed); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Task" field is required
    if strct.Task == nil {
        return nil, errors.New("task is a required field")
    }
    // Marshal the "task" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"task\": ")
	if tmp, err := json.Marshal(strct.Task); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckRequest) UnmarshalJSON(b []byte) error {
    check_inputReceived := false
    pathsReceived := false
    runReceived := false
    stepReceived := false
    taskReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "budgets":
            if err := json.Unmarshal([]byte(v), &strct.Budgets); err != nil {
                return err
             }
        case "check_input":
            if err := json.Unmarshal([]byte(v), &strct.CheckInput); err != nil {
                return err
             }
            check_inputReceived = true
        case "context":
            if err := json.Unmarshal([]byte(v), &strct.Context); err != nil {
                return err
             }
        case "paths":
            if err := json.Unmarshal([]byte(v), &strct.Paths); err != nil {
                return err
             }
            pathsReceived = true
        case "run":
            if err := json.Unmarshal([]byte(v), &strct.Run); err != nil {
                return err
             }
            runReceived = true
        case "step":
            if err := json.Unmarshal([]byte(v), &strct.Step); err != nil {
                return err
             }
            stepReceived = true
        case "stop_reasons_allowed":
            if err := json.Unmarshal([]byte(v), &strct.StopReasonsAllowed); err != nil {
                return err
             }
        case "task":
            if err := json.Unmarshal([]byte(v), &strct.Task); err != nil {
                return err
             }
            taskReceived = true
        }
    }
    // check if check_input (a required property) was received
    if !check_inputReceived {
        return errors.New("\"check_input\" is required but was not present")
    }
    // check if paths (a required property) was received
    if !pathsReceived {
        return errors.New("\"paths\" is required but was not present")
    }
    // check if run (a required property) was received
    if !runReceived {
        return errors.New("\"run\" is required but was not present")
    }
    // check if step (a required property) was received
    if !stepReceived {
        return errors.New("\"step\" is required but was not present")
    }
    // check if task (a required property) was received
    if !taskReceived {
        return errors.New("\"task\" is required but was not present")
    }
    return nil
}

func (strct *CheckRun) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Iteration" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "iteration" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"iteration\": ")
	if tmp, err := json.Marshal(strct.Iteration); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckRun) UnmarshalJSON(b []byte) error {
    idReceived := false
    iterationReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "iteration":
            if err := json.Unmarshal([]byte(v), &strct.Iteration); err != nil {
                return err
             }
            iterationReceived = true
        }
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if iteration (a required property) was received
    if !iterationReceived {
        return errors.New("\"iteration\" is required but was not present")
    }
    return nil
}

func (strct *CheckStep) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Index" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "index" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"index\": ")
	if tmp, err := json.Marshal(strct.Index); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckStep) UnmarshalJSON(b []byte) error {
    indexReceived := false
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "index":
            if err := json.Unmarshal([]byte(v), &strct.Index); err != nil {
                return err
             }
            indexReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        }
    }
    // check if index (a required property) was received
    if !indexReceived {
        return errors.New("\"index\" is required but was not present")
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *CheckTask) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcceptanceCriteria" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "acceptance_criteria" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"acceptance_criteria\": ")
	if tmp, err := json.Marshal(strct.AcceptanceCriteria); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Description" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "description" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Id" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"id\": ")
	if tmp, err := json.Marshal(strct.Id); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckTask) UnmarshalJSON(b []byte) error {
    acceptance_criteriaReceived := false
    descriptionReceived := false
    idReceived := false
    titleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acceptance_criteria":
            if err := json.Unmarshal([]byte(v), &strct.AcceptanceCriteria); err != nil {
                return err
             }
            acceptance_criteriaReceived = true
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
            descriptionReceived = true
        case "id":
            if err := json.Unmarshal([]byte(v), &strct.Id); err != nil {
                return err
             }
            idReceived = true
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        }
    }
    // check if acceptance_criteria (a required property) was received
    if !acceptance_criteriaReceived {
        return errors.New("\"acceptance_criteria\" is required but was not present")
    }
    // check if description (a required property) was received
    if !descriptionReceived {
        return errors.New("\"description\" is required but was not present")
    }
    // check if id (a required property) was received
    if !idReceived {
        return errors.New("\"id\" is required but was not present")
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    return nil
}

func (strct *CheckWorkPlan) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CheckSteps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "check_steps" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"check_steps\": ")
	if tmp, err := json.Marshal(strct.CheckSteps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "DoSteps" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "do_steps" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"do_steps\": ")
	if tmp, err := json.Marshal(strct.DoSteps); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "StopTriggers" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "stop_triggers" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop_triggers\": ")
	if tmp, err := json.Marshal(strct.StopTriggers); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "TimeboxMinutes" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "timebox_minutes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"timebox_minutes\": ")
	if tmp, err := json.Marshal(strct.TimeboxMinutes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckWorkPlan) UnmarshalJSON(b []byte) error {
    check_stepsReceived := false
    do_stepsReceived := false
    stop_triggersReceived := false
    timebox_minutesReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "check_steps":
            if err := json.Unmarshal([]byte(v), &strct.CheckSteps); err != nil {
                return err
             }
            check_stepsReceived = true
        case "do_steps":
            if err := json.Unmarshal([]byte(v), &strct.DoSteps); err != nil {
                return err
             }
            do_stepsReceived = true
        case "stop_triggers":
            if err := json.Unmarshal([]byte(v), &strct.StopTriggers); err != nil {
                return err
             }
            stop_triggersReceived = true
        case "timebox_minutes":
            if err := json.Unmarshal([]byte(v), &strct.TimeboxMinutes); err != nil {
                return err
             }
            timebox_minutesReceived = true
        }
    }
    // check if check_steps (a required property) was received
    if !check_stepsReceived {
        return errors.New("\"check_steps\" is required but was not present")
    }
    // check if do_steps (a required property) was received
    if !do_stepsReceived {
        return errors.New("\"do_steps\" is required but was not present")
    }
    // check if stop_triggers (a required property) was received
    if !stop_triggersReceived {
        return errors.New("\"stop_triggers\" is required but was not present")
    }
    // check if timebox_minutes (a required property) was received
    if !timebox_minutesReceived {
        return errors.New("\"timebox_minutes\" is required but was not present")
    }
    return nil
}
