// Code generated by schema-generate. DO NOT EDIT.

package check

import (
    "bytes"
    "encoding/json"
    "errors"
)

// CheckAcceptanceResult 
type CheckAcceptanceResult struct {
  AcId string `json:"ac_id"`
  Notes string `json:"notes,omitempty"`
  Result string `json:"result"`
}

// CheckOutput 
type CheckOutput struct {
  AcceptanceResults []CheckAcceptanceResult `json:"acceptance_results"`
  Verdict *CheckVerdict `json:"verdict"`
}

// CheckProgress 
type CheckProgress struct {
  Details []string `json:"details"`
  Title string `json:"title"`
}

// CheckResponse 
type CheckResponse struct {
  CheckOutput *CheckOutput `json:"check_output"`
  Progress *CheckProgress `json:"progress"`
  Status string `json:"status"`
  StopReason string `json:"stop_reason,omitempty"`
  Summary *CheckSummary `json:"summary"`
}

// CheckSummary 
type CheckSummary struct {
  Text string `json:"text"`
}

// CheckVerdict 
type CheckVerdict struct {
  Basis *CheckVerdictBasis `json:"basis"`
  Recommendation string `json:"recommendation"`
  Status string `json:"status"`
}

// CheckVerdictBasis 
type CheckVerdictBasis struct {
  AllAcceptancePassed bool `json:"all_acceptance_passed,omitempty"`
  PlanMatch string `json:"plan_match,omitempty"`
}

func (strct *CheckAcceptanceResult) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcId" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "ac_id" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"ac_id\": ")
	if tmp, err := json.Marshal(strct.AcId); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "notes" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"notes\": ")
	if tmp, err := json.Marshal(strct.Notes); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Result" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "result" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"result\": ")
	if tmp, err := json.Marshal(strct.Result); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckAcceptanceResult) UnmarshalJSON(b []byte) error {
    ac_idReceived := false
    resultReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "ac_id":
            if err := json.Unmarshal([]byte(v), &strct.AcId); err != nil {
                return err
             }
            ac_idReceived = true
        case "notes":
            if err := json.Unmarshal([]byte(v), &strct.Notes); err != nil {
                return err
             }
        case "result":
            if err := json.Unmarshal([]byte(v), &strct.Result); err != nil {
                return err
             }
            resultReceived = true
        }
    }
    // check if ac_id (a required property) was received
    if !ac_idReceived {
        return errors.New("\"ac_id\" is required but was not present")
    }
    // check if result (a required property) was received
    if !resultReceived {
        return errors.New("\"result\" is required but was not present")
    }
    return nil
}

func (strct *CheckOutput) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "AcceptanceResults" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "acceptance_results" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"acceptance_results\": ")
	if tmp, err := json.Marshal(strct.AcceptanceResults); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Verdict" field is required
    if strct.Verdict == nil {
        return nil, errors.New("verdict is a required field")
    }
    // Marshal the "verdict" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"verdict\": ")
	if tmp, err := json.Marshal(strct.Verdict); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckOutput) UnmarshalJSON(b []byte) error {
    acceptance_resultsReceived := false
    verdictReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "acceptance_results":
            if err := json.Unmarshal([]byte(v), &strct.AcceptanceResults); err != nil {
                return err
             }
            acceptance_resultsReceived = true
        case "verdict":
            if err := json.Unmarshal([]byte(v), &strct.Verdict); err != nil {
                return err
             }
            verdictReceived = true
        }
    }
    // check if acceptance_results (a required property) was received
    if !acceptance_resultsReceived {
        return errors.New("\"acceptance_results\" is required but was not present")
    }
    // check if verdict (a required property) was received
    if !verdictReceived {
        return errors.New("\"verdict\" is required but was not present")
    }
    return nil
}

func (strct *CheckProgress) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Details" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "details" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"details\": ")
	if tmp, err := json.Marshal(strct.Details); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Title" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "title" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckProgress) UnmarshalJSON(b []byte) error {
    detailsReceived := false
    titleReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "details":
            if err := json.Unmarshal([]byte(v), &strct.Details); err != nil {
                return err
             }
            detailsReceived = true
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
            titleReceived = true
        }
    }
    // check if details (a required property) was received
    if !detailsReceived {
        return errors.New("\"details\" is required but was not present")
    }
    // check if title (a required property) was received
    if !titleReceived {
        return errors.New("\"title\" is required but was not present")
    }
    return nil
}

func (strct *CheckResponse) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "CheckOutput" field is required
    if strct.CheckOutput == nil {
        return nil, errors.New("check_output is a required field")
    }
    // Marshal the "check_output" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"check_output\": ")
	if tmp, err := json.Marshal(strct.CheckOutput); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Progress" field is required
    if strct.Progress == nil {
        return nil, errors.New("progress is a required field")
    }
    // Marshal the "progress" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"progress\": ")
	if tmp, err := json.Marshal(strct.Progress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stop_reason" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop_reason\": ")
	if tmp, err := json.Marshal(strct.StopReason); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Summary" field is required
    if strct.Summary == nil {
        return nil, errors.New("summary is a required field")
    }
    // Marshal the "summary" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckResponse) UnmarshalJSON(b []byte) error {
    check_outputReceived := false
    progressReceived := false
    statusReceived := false
    summaryReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "check_output":
            if err := json.Unmarshal([]byte(v), &strct.CheckOutput); err != nil {
                return err
             }
            check_outputReceived = true
        case "progress":
            if err := json.Unmarshal([]byte(v), &strct.Progress); err != nil {
                return err
             }
            progressReceived = true
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        case "stop_reason":
            if err := json.Unmarshal([]byte(v), &strct.StopReason); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
            summaryReceived = true
        }
    }
    // check if check_output (a required property) was received
    if !check_outputReceived {
        return errors.New("\"check_output\" is required but was not present")
    }
    // check if progress (a required property) was received
    if !progressReceived {
        return errors.New("\"progress\" is required but was not present")
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    // check if summary (a required property) was received
    if !summaryReceived {
        return errors.New("\"summary\" is required but was not present")
    }
    return nil
}

func (strct *CheckSummary) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Text" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "text" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"text\": ")
	if tmp, err := json.Marshal(strct.Text); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckSummary) UnmarshalJSON(b []byte) error {
    textReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "text":
            if err := json.Unmarshal([]byte(v), &strct.Text); err != nil {
                return err
             }
            textReceived = true
        }
    }
    // check if text (a required property) was received
    if !textReceived {
        return errors.New("\"text\" is required but was not present")
    }
    return nil
}

func (strct *CheckVerdict) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Basis" field is required
    if strct.Basis == nil {
        return nil, errors.New("basis is a required field")
    }
    // Marshal the "basis" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"basis\": ")
	if tmp, err := json.Marshal(strct.Basis); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Recommendation" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "recommendation" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"recommendation\": ")
	if tmp, err := json.Marshal(strct.Recommendation); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Status" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "status" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"status\": ")
	if tmp, err := json.Marshal(strct.Status); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CheckVerdict) UnmarshalJSON(b []byte) error {
    basisReceived := false
    recommendationReceived := false
    statusReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "basis":
            if err := json.Unmarshal([]byte(v), &strct.Basis); err != nil {
                return err
             }
            basisReceived = true
        case "recommendation":
            if err := json.Unmarshal([]byte(v), &strct.Recommendation); err != nil {
                return err
             }
            recommendationReceived = true
        case "status":
            if err := json.Unmarshal([]byte(v), &strct.Status); err != nil {
                return err
             }
            statusReceived = true
        }
    }
    // check if basis (a required property) was received
    if !basisReceived {
        return errors.New("\"basis\" is required but was not present")
    }
    // check if recommendation (a required property) was received
    if !recommendationReceived {
        return errors.New("\"recommendation\" is required but was not present")
    }
    // check if status (a required property) was received
    if !statusReceived {
        return errors.New("\"status\" is required but was not present")
    }
    return nil
}
